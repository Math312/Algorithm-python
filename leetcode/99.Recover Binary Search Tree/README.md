# 99. 恢复二叉搜索树

## 题目

二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

**示例 1**:

```
输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
```

**示例 2**:

```
输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3

```

**进阶**:

使用 O(n) 空间复杂度的解法很容易实现。

你能想出一个只使用常数空间的解决方案吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/recover-binary-search-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 解题思路

由于给定的树是一个二叉搜索树，因此证明其是有序的，因此就可以立刻想到可能与中序遍历有关，题目中给出二叉搜索树的两个节点相互交换了，因此可以知道中序遍历的结果将不再是有序的，由于只有两个节点有变化，因此可以找出两个节点进行交换即可，而找出节点的方法就可以采用中序遍历。

那么现在最重要的是如何使用中序遍历。事实上我们并没有一个标准可以在一次遍历过程中找到两个节点，这两个节点的状态太多了，因此我们选择两次遍历，只不过这两次遍历并不是遍历完整棵树，而是找到我们需要的节点就停止。

大致思路如下：

1. 通过第一次中序遍历找出第一个交换错的节点，只需要找到前一个节点大于当前节点的那个节点即可
2. 根据找到的节点进行第二次中序遍历，找到第一个大于当前节点的节点，然后两节点的value值进行交换

以示例2为例：

```
输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2
```

首先进行第一次中序遍历，找到前一个节点大于当前节点的那个节点，即2节点；然后再次进行第二次遍历，找到第一个大于2节点的节点，即3节点，将两个节点进行交换。

因此解决该问题的时间复杂度和 空间复杂度就取决于使用的中序遍历算法，常用的中序遍历算法有递归实现和迭代实现两种，这两种实现的时间复杂度都是O(n)，空间复杂度也是O(n)，有一种特殊的中序遍历算法，其时间复杂度是O(n)，空间复杂度是O(1)。我们采用三种方法解决该问题：

1. [recover_tree_iteraction.py](recover_tree_iteraction.py)使用基于迭代的中序遍历解决该问题
2. [recover_tree_recursive.py](recover_tree_recursive.py)使用基于迭代的中序遍历解决该问题
3. [recover_tree_mirrors.py](recover_tree_mirrors.py)使用Mirror中序遍历解决该问题